#;
(in-test-group
 overincorporation

 ;; The bug this test is checking for is that coupled assessment in
 ;; the old trace might mistakenly use the local state from the end
 ;; of the run, rather than from the point in the run at which
 ;; assessment is called.
 ;;
 ;; Note: PETs will produce a different valid proposal in this
 ;; situation.  To wit, since in PETs the local state is actually
 ;; exchangeable, it is valid to use the final state, except for
 ;; unincorporating the choice to be proposed and anything else in
 ;; the brush.  That state then gets used by both the proposal
 ;; distribution and the assessment.  RandomDB can't use that state
 ;; for the proposal distribution, so it must not use it for
 ;; assessment either.

 ;; An example sufficient to exhibit that problem is two flips of a
 ;; collapsed assessable beta bernoulli (two because one of them
 ;; will be chosen as the resimulation target).
 (define program
   `(begin
      ,map-defn
      ,mcmc-defn
      ,observe-defn
      (model-in (rdb-extend (get-current-trace))
        (assume make-u-bb ,collapsed-assessable-beta-bernoulli-maker)
        (assume coin (make-u-bb))
        (assume f1 (coin))
        (assume f2 (coin))
        (let ((initial (predict (cons f1 f2))))
          (infer (mcmc 1))
          ;; We want to check that the transition operator is right.
          (list initial (predict (cons f1 f2)))))))

 ;; The distribution on the first predict of the program
 (define initial-dist
   '(((#t . #t) . 1/3) ((#f . #f) . 1/3) ((#t . #f) . 1/6) ((#f . #t) . 1/6)))

 ;; The correct transition operator
 (define (true-post-infer-dist init)
   (chain-with freqs-bind
     (prop-index <- '((0 . 1/2) (1 . 1/2)))
     (prop-value <- (if (= prop-index 0)
                        '((#t . 1/2) (#f . 1/2))
                        (if (car init)
                            '((#t . 2/3) (#f . 1/3))
                            '((#t . 1/3) (#f . 2/3)))))
     (accept-prob <= (if (= prop-index 1)
                         1 ;; Nothing more to condition on
                         (if (equal? prop-value (car init))
                             1 ;; No rejecting non-moves
                             (if (equal? prop-value (cdr init))
                                 1 ;; (min 1 2) b/c moving to favorable state
                                 1/2 ;; M-H ratio for the move to the unfavorable state
                                 ))))
     (accept <- `((#t . ,accept-prob) (#f . ,(- 1 accept-prob))))
     (freqs-return
      (if accept
          (if (= prop-index 0)
              (cons prop-value (cdr init))
              (cons (car init) prop-value))
          init))))

 ;; The buggy transition operator
 (define (assess-bug-post-infer-dist init)
   (chain-with freqs-bind
     (prop-index <- '((0 . 1/2) (1 . 1/2)))
     (prop-value <- (if (= prop-index 0)
                        '((#t . 1/2) (#f . 1/2))
                        (if (car init)
                            '((#t . 2/3) (#f . 1/3))
                            '((#t . 1/3) (#f . 2/3)))))
     (assessment-weight <= (cond ((equal? init '(#t . #t)) 3/4)
                                 ((equal? init '(#t . #f)) 1/2)
                                 ((equal? init '(#f . #t)) 1/2)
                                 ((equal? init '(#f . #f)) 1/4)))
     ;; Note assessment against the full state generated by the
     ;; initial draw; the proper thing to assess against would have
     ;; been only the state computed up to the point at which this
     ;; choice is made.
     (assessor <= (lambda (v) (if v assessment-weight (- 1 assessment-weight))))
     (accept-prob <= (if (= prop-index 0)
                         ;; Will absorb the second flip.
                         (let ((prob-from-new-trace (if (equal? (cdr init) prop-value) 2/3 1/3)))
                           (min 1 (/ prob-from-new-trace (assessor (car init)))))
                         ;; Will absorb the first flip
                         (let ((prob-from-new-trace 1/2))
                           (min 1 (/ prob-from-new-trace (assessor (cdr init)))))))
     ; (_ <= (pp `(model ,init ,prop-index ,prop-value ,assessment-weight ,accept-prob)))
     (accept <- `((#t . ,accept-prob) (#f . ,(- 1 accept-prob))))
     (freqs-return
      (if accept
          (if (= prop-index 0)
              (cons prop-value (cdr init))
              (cons (car init) prop-value))
          init))))

 (define-test (transition-operator)
   (let ()
     (define answer
       (freqs-normalize
        (chain-with freqs-bind
          (init <- initial-dist)
          (post <- (true-post-infer-dist init))
          (freqs-return (list init post)))
        data<))
     #;
     (pp (cons 'true-transition-operator
               (map (lambda (item prob)
                      (cons item (* 72 3 prob)))
                    (map car answer)
                    (map cdr answer))))
     (define assess-bug-answer
       (freqs-normalize
        (chain-with freqs-bind
          (init <- initial-dist)
          (post <- (assess-bug-post-infer-dist init))
          (freqs-return (list init post)))
        data<))
     #;
     (pp (cons 'assess-bug-transition-operator
               (map (lambda (item prob)
                      (cons item (* 72 3 prob)))
                    (map car assess-bug-answer)
                    (map cdr assess-bug-answer))))

     ;; Actually generate samples from the program and check them
     (let* ((result (collect-samples program (* 72 3 10)))
            (vs-truth (chi-sq-test result answer))
            (vs-assess-bug (chi-sq-test result assess-bug-answer)))
       ;; System should approximate the true behavior
       (check (> vs-truth *p-value-tolerance*))
       ;; We want enough statistical strength to be confident that
       ;; system does not have the assess bug
       (check (< vs-assess-bug (* *p-value-tolerance* 0.1))))))

 (define-test (result-distribution)
   (let* ((samples (map cadr (collect-samples program (* 6 500))))
          (vs-truth (chi-sq-test samples initial-dist))
          (assess-bug-dist (freqs-normalize (freqs-bind initial-dist assess-bug-post-infer-dist) data<))
          (vs-assess-bug (chi-sq-test samples assess-bug-dist)))
     (check (> vs-truth *p-value-tolerance*))
     (check (< vs-assess-bug (* *p-value-tolerance* 0.1)))))

 )
